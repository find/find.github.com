<!doctype HTML>
<html>
<head>
<meta name="viewport" content="width=1100, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<title>Anti OCR</title>
<style>
.container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: stretch;
  min-width: 300px;
  max-width: 800px;
  margin: 0 auto;
  padding: 10px;
}
#execute {
  height: 3em;
  font-weight: bold;
  font-family: sans-serif;
  font-size: 2em;
  margin: 20px;
}
#download {
  margin: 0;
  padding: 0.5em;
  font-size: 1.5em;
  width: 100%;
}
#view {
  margin: 0;
  padding: 0.5em;
  font-size: 1em;
  width: 100%;
}
#input {
  font-family: serif;
  font-size: 1.5em;
  resize: vertical;
}
canvas {
  border: none;
  padding: 0 auto;
  margin: 0;
}
#output-container {
  border: 1px solid black;
  display: block;
  padding: 0;
  margin: 0 auto;
  width: 800px;
  height: 600px;
  resize: both;
  overflow: auto;
}
#config {
  background: #f7f7f7;
  border: 2px solid #aaa;
}
.parm > span {
  margin: 0 0.5em;
}
.parm > input[type=checkbox] {
  scale:2;
  margin:2em;
}
.parm > .label {
  display: inline-block;
  width: 7em;
}
.parm > .parmvalue {
  font-size: 1.5em;
}
.parm > label {
  display: inline-block;
  width: 5em;
  font-size: 1.4em;
  vertical-align: middle;
}
.label {
  font-size: 1.8em;
}
</style>
<script>
const SERIF_FONT = 'Source Han Serif, 思源宋体, STSong, FangSong, serif';
const SANS_SERIF_FONT = 'Source Han Sans, 思源黑体, Microsoft YaHei, sans-serif';
let W = 800;
let H = 600;
let CANVAS2D = null;
let GL = null;
let PROG = null;
let UNIFORM = {};
let PADDING = 20;
let YSPACE = 19; // y-direction spacing between characters
let XSPACE = 24; // x-direction spacing between characters
let ENSPACE = YSPACE/2; // ' ' spacing
let NORMAL_FONT = `16px ${SERIF_FONT}`;
let BOLD_FONT = `bold 16px ${SANS_SERIF_FONT}`;
let ITALIC_FONT = `italic 16px ${SANS_SERIF_FONT}`;
let TITLE_FONT = `bolder 22px ${SANS_SERIF_FONT}`;
let JITTER = 0;

var $ = id=>document.getElementById(id);
const randint = (min, max)=>Math.floor(Math.random()*(max-min+1)+min);
const randfloat = (min, max)=>Math.random()*(max-min)+min;
const lerp = (x,y,t)=>(y-x)*t+x;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
function doTheJob() {
  if ($('autoredraw').checked)
    render();
}
function initGL() {
  CANVAS2D = document.createElement('canvas');
  CANVAS2D.width = W;
  CANVAS2D.height = H;

  let gl = $('output').getContext('webgl', {preserveDrawingBuffer: true});
  const VS_CODE = `precision mediump float;
  attribute vec3 position;
  uniform vec2 size;
  varying vec2 uv;
  varying vec2 screenpos;
  void main()
  {
    uv = position.xy*vec2(0.5,-0.5)+0.5;
    screenpos = uv*size;
    gl_Position = vec4(position, 1.0);
  }`;
  const PS_CODE = `precision mediump float;
  uniform sampler2D texture;
  uniform vec2 size;
  uniform vec3 distortPoints[20];
  uniform int  numDistortPoints;
  uniform float distortStrength;
  uniform float fontSize;
  uniform int glitch;
  uniform float jitter;
  uniform float seed;
  varying vec2 uv;
  varying vec2 screenpos;
  #define PI 3.1415926535898
  // from https://www.shadertoy.com/view/ft3fz4 
  vec3 hash33(vec3 p){
      p = vec3(
          dot(p, vec3(13.13, 63.22, 75.46)),
          dot(p, vec3(48.68, 75.13, 84.94)),
          dot(p, vec3(94.78, 41.42, 86.35)));
      return -1. + 2. * fract(sin(p) * 43241.1313187);
  }

  float perlin(vec3 p, vec3 period){
      vec3 pi = floor(p);
      vec3 pf = p - pi;
      
      vec3 w = pf * pf * (3.0 - 2.0 * pf);
      return mix(mix(mix(dot(hash33(mod(pi + vec3(0.0, 0.0, 0.0), period)), pf - vec3(0.0, 0.0, 0.0)), 
                        dot(hash33(mod(pi + vec3(1.0, 0.0, 0.0), period)), pf - vec3(1.0, 0.0, 0.0)), w.x), 
                    mix(dot(hash33(mod(pi + vec3(0.0, 1.0, 0.0), period)), pf - vec3(0.0, 1.0, 0.0)), 
                        dot(hash33(mod(pi + vec3(1.0, 1.0, 0.0), period)), pf - vec3(1.0, 1.0, 0.0)), w.x),
                    w.y),
                mix(mix(dot(hash33(mod(pi + vec3(0.0, 0.0, 1.0), period)), pf - vec3(0.0, 0.0, 1.0)), 
                        dot(hash33(mod(pi + vec3(1.0, 0.0, 1.0), period)), pf - vec3(1.0, 0.0, 1.0)), w.x), 
                    mix(dot(hash33(mod(pi + vec3(0.0, 1.0, 1.0), period)), pf - vec3(0.0, 1.0, 1.0)), 
                        dot(hash33(mod(pi + vec3(1.0, 1.0, 1.0), period)), pf - vec3(1.0, 1.0, 1.0)), w.x),
                    w.y),
                w.z);
  }

  float perlin_fbm(vec3 p, vec3 scale, vec3 period){
      float fbm = 0.;
      float weight = 1.;
      float weightsum = 0.;
      for(int i = 0; i < 4; i++){ // octave==4
          weightsum += weight;
          fbm += weight * perlin(p * scale, period) * 2.;
          weight *= 0.5;
          scale *= 2.;
          period *= 2.;
      }
      fbm /= weightsum;
      //fbm = fbm * .5 + .5;
      //fbm = clamp(fbm, 0., 1.);
      return fbm;
  }

  float worley(vec3 p, vec3 period){
      vec3 pi = floor(p);
      float mndis = 1e9;
      for(int i = -1; i <= 2; i++){
          for(int j = -1; j <= 2; j++){
              for(int k = -1; k <= 2; k++){
                  vec3 keypoint = pi + vec3(i, j, k) + hash33(mod(pi + vec3(i, j, k), period));
                  float dis = dot(p - keypoint, p - keypoint);
                  mndis = min(dis, mndis);
              }
          }
      }
      return mndis;
  }

  float worley_fbm(vec3 p, vec3 scale, vec3 period){
      float fbm = 1.;
      float weight = 1.;
      float weightsum = 0.;
      for(int i = 0; i < 4; i++){ // octave==4
          weightsum += weight;
          fbm *= 1. - weight * worley(p * scale, period);
          weight *= .5;
          scale *= 2.;
          period *= 2.;
      }
      fbm /= weightsum;
      return fbm;
  }
  // end https://www.shadertoy.com/view/ft3fz4

  float dist(vec2 a, vec2 b)
  {
    float dx=a.x-b.x, dy=a.y-b.y;
    return sqrt(dx*dx+dy*dy);
  }
  void main()
  {
    float strength = distortStrength;
    float dx=0.0, dy=0.0;
    for (int i=0; i<20; ++i) {
      vec3 pt = distortPoints[i];
      float d=dist(screenpos, pt.xy);
      float w=pt.z;
      if (i<numDistortPoints && d<w*strength) {
        float m = mix(0.0,fontSize*4.0,pow(sin(clamp(d,0.0,strength*w)/strength/w*PI)*0.6,3.0));
        dy += (pt.y-screenpos.y)/d * m;
        dx += (pt.x-screenpos.x)/d * m;
      }
    }
    vec2 sampleuv = uv + vec2(dx,dy)/size;
    if (glitch>0) {
      sampleuv.x += perlin_fbm(vec3(0,floor(screenpos.y/20.),seed), vec3(1.0,1.0,1.0), vec3(200.0,200.0,200.0))*0.007;
    }
    gl_FragColor = texture2D(texture, sampleuv);
  }`;

  let vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, VS_CODE);
  gl.compileShader(vs);

  let ps = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(ps, PS_CODE);
  gl.compileShader(ps);

  let prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, ps);
  gl.linkProgram(prog);

  const vertices = [
    -1,  1,  0,
    -1, -1,  0,
     1, -1,  0,
     1,  1,  0 
  ];
  const indices = [3,2,1,3,1,0];

  let quadVB = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVB);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  let quadIB = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIB);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.clearColor(0.5, 0.5, 0.8, 0.9);
  gl.viewport(0,0,W,H);
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVB);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadIB); 

  gl.useProgram(prog);
  const attP = gl.getAttribLocation(prog, "position");
  const texP = gl.getUniformLocation(prog, "texture");
  const size = gl.getUniformLocation(prog, "size");
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, ctx.getImageData(0,0,W,H).data);
  gl.uniform2f(size, W, H);
  gl.enableVertexAttribArray(attP);
  gl.vertexAttribPointer(attP, 3, gl.FLOAT, false, 0, 0);

  GL = gl;
  PROG = prog;
  UNIFORM = {
    texture: texP,
    size: size,
    distortPoints: gl.getUniformLocation(prog, "distortPoints"),
    distortStrength: gl.getUniformLocation(prog, "distortStrength"),
    numDistortPoints: gl.getUniformLocation(prog, "numDistortPoints"),
    fontSize: gl.getUniformLocation(prog, "fontSize"),
    glitch: gl.getUniformLocation(prog, "glitch"),
    jitter: gl.getUniformLocation(prog, "jitter"),
    seed: gl.getUniformLocation(prog, "seed"),
  };
}
function render() {
  let ctx = CANVAS2D.getContext('2d');

  const invert = $('invert').checked;
  const clearcolor = invert?'#222':'white';
  const fillcolor  = invert?'white':'#222';
  ctx.fillStyle = clearcolor;
  ctx.fillRect(0,0,W,H);

  const nf = NORMAL_FONT;
  NORMAL_FONT = `bold ${nf}`;
  const fontsize=Number($('font-size').value);
  const glitch = $('glitch').checked;
  if (glitch) {
    if (invert)
      ctx.strokeStyle='#444';
    else
      ctx.strokeStyle='#ccc';

    for (let i=0; i<10; ++i) {
      let x = randint(-W/4, W*1.25), y = randint(-H/4, H*1.25);
      let c = randint(20, Math.min(W,H));
      let lw = randint(18, 36);
      for (let cc=c/3, i=1; cc<c; cc*=1.5, ++i) {
        ctx.lineWidth=lw/i;
        ctx.beginPath();
        ctx.arc(x,y,cc,0,2*Math.PI);
        ctx.stroke();
        ctx.closePath();
      }
    }
  }
  const xoffset = (Number($('x-shift').value)/100.0-1) * W
  const endpoint = drawText(ctx, [xoffset,0], fillcolor);
  NORMAL_FONT = nf;

  if ($('fill').checked) {
    if (invert)
      ctx.fillStyle='white';
    else
      ctx.fillStyle='black';
    ctx.font = BOLD_FONT;
    for (let y=PADDING; y<H-PADDING; y+=YSPACE*1.4) {
      for (let x=PADDING+randint(0,0)*XSPACE, e=endpoint[0]; x<e; x+=XSPACE/1.4) {
        ctx.fillText('锟斤拷烫烫烫烫'[randint(0,6)], x, y);
      }
      for (let x=W+xoffset, e=W-PADDING-randint(0,8)*XSPACE; x<e; x+=XSPACE/1.4) {
        ctx.fillText('锟斤拷烫烫烫烫'[randint(0,6)], x, y);
      }
    }
  }

  /*
  if ($("distort").checked) {
    let img = ctx.getImageData(0,0,W,H);
    let out = ctx.createImageData(W,H);
    let pts = [];
    for (let i=0; i<Number($('distort-cnt').value); ++i) {
      pts.push({x:randint(0,W), y:randint(0,H), w:randfloat(5,14)});
    }
    const strength = Number($('distort-strength').value);
    const dist=(a,b)=>{let dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); };
    for (let y=0; y<H; ++y) {
      for (let x=0; x<W; ++x) {
        let dx = 0, dy = 0;
        let npt = 0;
        for (let idx=0; idx<pts.length; ++idx) {
          const pt = pts[idx];
          let d=dist(pt,{x:x, y:y});
          const w=pt.w;
          if (d<w*strength) {
            const m = lerp(0,fontsize*4,Math.pow(Math.sin(clamp(d,0,strength*w)/strength/w*Math.PI)*0.6,3));
            dy += (pt.y-y)/d * m;
            dx += (pt.x-x)/d * m;
            ++npt;
          }
        }
        const j=y*W*4+x*4;
        let i=j;
        if (npt>0) {
          const ix = x + dx;
          const iy = y + dy;
          i=Math.round(iy)%H*W*4+Math.round(ix)%W*4;
        }
        out.data[j  ]=img.data[i  ];
        out.data[j+1]=img.data[i+1];
        out.data[j+2]=img.data[i+2];
        out.data[j+3]=255;
      }
    }
    ctx.putImageData(out,0,0);
  }
  if (glitch) {
    let img = ctx.getImageData(0,0,W,H);
    let out = ctx.createImageData(W,H);
    for (let y1=0; y1<H;) {
      let y2 = y1+randint(20, 120);
      if (y2>H) y2=H;
      let shift = [1,1,1];
      if (glitch)
        shift = [randfloat(0.8, 1.2), randfloat(0.8,1.2), randfloat(0.8,1.2)];
      const xoffset = Math.floor((Math.random()*fontsize/2-fontsize/4)*JITTER*6);
      const J = JITTER*2;
      let cyanoffset = [randint(-fontsize/10*J, fontsize/10*J), randint(-fontsize/12*J, fontsize/12*J)];
      let fuchsiaoffset = [randint(-fontsize/10*J, fontsize/10*J), randint(-fontsize/12*J, fontsize/12*J)];
      for (let y=y1; y<y2; ++y) {
        let lineoffset = randint(-J/2,J/2);
        for (let x=0; x<W; ++x) {
          const i=y*W*4+(x+xoffset)%W*4;
          const j=y*W*4+x*4;
          let [r, g, b] = [img.data[i], img.data[i+1], img.data[i+2]]
          if (glitch) {
            const c=(y+cyanoffset[1])%H*W*4+(x+xoffset+lineoffset+cyanoffset[0])%W*4;
            const f=(y+fuchsiaoffset[1])%H*W*4+(x+xoffset+lineoffset+fuchsiaoffset[0])%W*4;
            let cr = img.data[c]
            let fr = img.data[f]
            if (invert) {
              if (cr>180) {
                g += 200;
                b += 200;
              }
              if (fr>180) {
                r += 200;
                b += 200;
              }
            } else {
              if (cr<100)
                r *= 0.25;
              if (fr<100)
                g *= 0.25;
            }
          }
          out.data[j  ] = r*shift[0];
          out.data[j+1] = g*shift[1];
          out.data[j+2] = b*shift[2];
          out.data[j+3] = 255;
        }
      }
      y1 = y2;
    }
    ctx.putImageData(out, 0,0);
  }
  */

  let gl = GL;
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, ctx.getImageData(0,0,W,H).data);
  let npt = clamp(Number($('distort-cnt').value), 0, 20);
  let pts = []
  for (let i=0; i<npt; ++i) {
    pts.push(randint(0,W));
    pts.push(randint(0,H));
    pts.push(randfloat(5,14));
  }
  gl.useProgram(PROG);
  gl.uniform2f(UNIFORM.size, W, H);
  gl.uniform3fv(UNIFORM.distortPoints, pts);
  gl.uniform1i(UNIFORM.numDistortPoints, npt);
  gl.uniform1f(UNIFORM.distortStrength, Number($('distort-strength').value));
  gl.uniform1f(UNIFORM.fontSize, fontsize);
  gl.uniform1f(UNIFORM.seed, Math.random());
  gl.uniform1i(UNIFORM.glitch, glitch);
  gl.uniform1f(UNIFORM.jitter, JITTER);
 
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}
function drawText(ctx, offset, color) {
  let msg = $('input').value
    .replaceAll('“', '﹃')
    .replaceAll('”', '﹄')
    .replaceAll('‘', '﹁')
    .replaceAll('’', '﹂')
    .replaceAll('《', '︽')
    .replaceAll('》', '︾')
    .replaceAll('{', '︷')
    .replaceAll('}', '︸')
    .replaceAll('[', '︻')
    .replaceAll(']', '︼')
    .replaceAll('【', '︻')
    .replaceAll('】', '︼')
    .replaceAll('(', '︵')
    .replaceAll(')', '︶')
    .replaceAll('（', '︵')
    .replaceAll('）', '︶')
    .replaceAll('…', '⋮')
    .replaceAll('—', '︱');
  ctx.font = NORMAL_FONT;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillStyle = color;

  let charsize = ctx.measureText('啊');
  let x=W-PADDING-charsize.width/2+offset[0], y=PADDING+offset[1];
  let firstline = true;
  let bold = false;
  let italic = false;
  for (let line of msg.split('\n')) {
    let title = line.match(/^#\s*(.+)$/);
    let yspace = YSPACE;
    if (title) {
      ctx.font = TITLE_FONT;
      line = title[1]
      if (!firstline) {
        x-=XSPACE;
      }
      yspace = YSPACE*1.4; // larger spacing
    } else {
      ctx.font = NORMAL_FONT;
      bold = false; // new line clears style
    }
    yspace -= JITTER*YSPACE*0.1;
    for (let i=0; i<line.length; ++i) {
      //ctx.fillStyle='#a33';
      //ctx.fillRect(x-2,y-2,4,4); // debug
      ctx.fillStyle=color;
      let c = line[i];
      let rand = ()=>Math.random();
      let jitter = [(rand()*XSPACE/4-XSPACE/8)*JITTER, (rand()*YSPACE/4-YSPACE/8)*JITTER];
      if (!title && c=='\\') {
        if (i<line.length && line[i+1]=='*') {
          ++i;
          c = '*';
        }
        if (i<line.length && line[i+1]=='_') {
          ++i;
          c = '_';
        }
      } else if (c=='*') {
        bold = !bold;
        if (bold)
          ctx.font = BOLD_FONT;
        else
          ctx.font = NORMAL_FONT;
        continue;
      } else if (c=='_') {
        italic = !italic;
        if (italic)
          ctx.font = ITALIC_FONT;
        else
          ctx.font = NORMAL_FONT;
        continue;
      }
      if (c.match(/[\p{Script=Latin}0-9_@\-$%'"]/iu)) {
        let s = c;
        //console.log(`Enter latin block '${c}'`);
        let lastblock = s;
        let lasti = i;
        for (++i; i<line.length; ++i) {
          let cc=line[i];
          if (cc.match(/[\p{Script=Latin}0-9\\\/]/iu)) {
            //console.log(`latin: '${cc}'`)
            s += cc;
          } else if (cc.match(/[.,:;_\-!@#$%^&*'" ]/)) {
            //console.log(`check bound: '${cc}'`)
            let met = ctx.measureText(s+cc);
            let tw = met.width;
            if (y+tw > H-PADDING) {
              //console.log(`out of bound: "${s}"", fallback to "${lastblock}"`);
              if (lastblock!=c) {
                s=lastblock;
                i=lasti;
              }
              break;
            } else {
              lastblock = s
              lasti = i;
              s += cc;
            }
          } else
            break;
        }
        //console.log(`end latin block: "${s}"`);
        --i;

        if (s.length>1) {
          let met = ctx.measureText(s);
          let tw = met.width;
          if (y+tw > H-PADDING) {
            y = PADDING;
            x -= XSPACE;
          }
          ctx.save();
          ctx.textAlign='left';
          ctx.textBaseline='middle';
          ctx.translate(x+jitter[0],y+jitter[1]);
          ctx.rotate(Math.PI/2);
          ctx.fillText(s,0,0);
          ctx.restore();
          y += tw-yspace+ENSPACE/2;
        } else {
          ctx.fillText(c, x+jitter[0], y+jitter[1]);
        }
      } else if (c==' ') {
        y -= yspace-ENSPACE;
      } else {
        let kerning=[0,0];
        if (c.match(/[，。、]/u)) {
          kerning = [charsize.width/3, -yspace/2];
        }
        ctx.save();
        ctx.translate(x+kerning[0]+jitter[0], y+kerning[1]+jitter[1]);
        let rot = (rand()*Math.PI/6-Math.PI/12)*JITTER;
        ctx.rotate(rot);
        let scale = 1+(rand()-0.5)*0.4*JITTER; 
        ctx.scale(scale, scale);
        ctx.fillText(c, 0,0);
        ctx.restore();
        y -= (1-scale)*yspace;
      }
      y += yspace;
      if (y+yspace>=H-PADDING) {
        y = PADDING;
        x -= XSPACE;
      }
    }
    y = PADDING;
    x -= XSPACE;
    if (title) // extra space
      x -= XSPACE/2;
    firstline = false;
  }
  return [x, y];
}

function updateFonts() {
  let v=$('font-size').value
  $('font-size-disp').innerHTML=v
  let dpr = window.devicePixelRatio || 1.0;
  v = Number(v)*dpr;
  YSPACE = Math.ceil(v*1.15);
  XSPACE = Math.ceil(v*1.5);
  ENSPACE = Math.ceil(v*1.15*0.5);
  PADDING = v*1.4;
  NORMAL_FONT = `${Math.ceil(v)}px ${SERIF_FONT}`;
  ITALIC_FONT = `italic ${Math.ceil(v)}px ${SERIF_FONT}`;
  BOLD_FONT = `bold ${Math.ceil(v)}px ${SANS_SERIF_FONT}`;
  TITLE_FONT = `bolder ${Math.ceil(v*1.375)}px ${SANS_SERIF_FONT}`;
}
function onResize() {
  let canvas = $('output');
  let scale = window.devicePixelRatio || 1;
  let container = $('output-container');
  canvas.width = (container.clientWidth-2)*scale;
  canvas.height = (container.clientHeight-4)*scale;
  canvas.style.width = `${container.clientWidth-2}px`;
  canvas.style.height = `${container.clientHeight-4}px`;
  W = canvas.width;
  H = canvas.height;
  initGL();
  updateFonts();
  doTheJob();
}
function checkDistortParms() {
  if ($('distort').checked) {
    $('distort-parms').style='display:block; background-color: #ccc; border:1px solid #888; margin: 8px;';
  } else {
    $('distort-parms').style='display:none';
  }
  $('distort-cnt-disp').innerHTML = $('distort-cnt').value
  $('distort-strength-disp').innerHTML = $('distort-strength').value
  doTheJob();
}

//window.addEventListener('resize', onResize);
window.addEventListener('load', function() {
  initGL();
  $('execute').onclick=render;
  $('input').oninput=doTheJob;
  new ResizeObserver(onResize).observe($('output-container'));
  $('font-size').oninput=()=>{
    updateFonts();
    doTheJob();
  };
  $('jitter').oninput=()=>{
    let v=$('jitter').value;
    $('jitter-disp').innerHTML = `${v}%`;
    JITTER = Number(v)/100.0;
    doTheJob();
  };
  $('x-shift').oninput=()=>{
    $('x-shift-disp').innerHTML = `${$('x-shift').value}%`;
    doTheJob();
  }
  $('jitter').oninput();
  $('glitch').onchange=doTheJob;
  $('invert').onchange=doTheJob;
  $('autoredraw').onchange=doTheJob;
  $('fill').onchange=doTheJob;
  $('distort').onchange=checkDistortParms;
  $('distort-cnt').onchange=checkDistortParms;
  $('distort-strength').onchange=checkDistortParms;
  $('download').onclick=()=>{
    let img=$('output').toDataURL('image/png').replace('image/png', 'image/octet-stream');
    let now=new Date();
    $('download-anchor').setAttribute('download', `${now.getFullYear()}-${now.getMonth()}-${now.getDay()}-${now.getHours()}-${now.getMinutes()}.png`)
    $('download-anchor').setAttribute('href', img);
  }
  $('view').onclick=()=>{
    let dataurl=$('output').toDataURL('image/png');
    let tab = window.open(dataurl);
    setTimeout(() => {
      let image = new Image();
      image.src = dataurl;
      tab.document.write(image.outerHTML);
    }, 0);
  }
  checkDistortParms();
  $('x-shift').oninput();
  onResize();
});
</script>
</head>

<body>
<div class="container">
<p class="label">Input:</p>
<textarea id="input" rows="12">
</textarea>

<p class="label">Config:</p>
<div id="config">
  <div class="parm"><span class="label">Font Size:</span><input id="font-size" style="width:50%" type="range" min="10" max="80" value="16" class="slider"/><span class="parmvalue" id="font-size-disp">16</span></div>
  <div class="parm"><span class="label">Jitter:</span><input id="jitter" style="width:50%" type="range" min="0" max="200" value="0" class="slider"/><span class="parmvalue" id="jitter-disp">0%</span></div>
  <div class="parm"><span class="label">X-Shift:</span><input id="x-shift" style="width:50%" type="range" min="0" max="100" value="100" class="slider"/><span class="parmvalue" id="x-shift-disp">100%</span></div>
  <div>
    <div class="parm" style="display:inline-block"><input id="autoredraw" type="checkbox" checked/><label for="autoredraw">Auto Draw</label></div>
    <div class="parm" style="display:inline-block"><input id="glitch" type="checkbox"/><label for="glitch">Glitch</label></div>
    <div class="parm" style="display:inline-block"><input id="invert" type="checkbox"/><label for="invert">Invert</label></div>
    <div class="parm" style="display:inline-block"><input id="fill" type="checkbox"/><label for="fill">Fill Garbles</label></div>
    <div class="parm" style="display:inline-block"><input id="distort" type="checkbox"/><label for="distort">Distort</label></div>
  </div>
  <div id="distort-parms">
    <div class="parm"><span class="label">Distort Amount:</span><input id="distort-cnt" style="width:50%" type="range" min="1" max="20" value="10" class="slider"/><span class="parmvalue" id="distort-cnt-disp">10</span></div>
    <div class="parm"><span class="label">Distort Strength:</span><input id="distort-strength" style="width:50%" type="range" min="0" max="80" value="30" class="slider"/><span class="parmvalue" id="distort-strength-disp">30</span></div>
  </div>
</div>

<p class="label">Output:</p>
</div>

<div id="output-container">
  <canvas id="output"></canvas>
</div>

<div class="container">
<button id="execute">Update</button>
<button id="view">View In New Tab</button>
<a id="download-anchor" download="image.png">
  <button id="download">Download Image</button>
</a>

</div>
</body>

</html>
