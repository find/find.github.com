<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title>Lua 源码阅读笔记</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="lua">
<h1 class="title">Lua 源码阅读笔记</h1>

<div class="contents topic" id="id1">
<p class="topic-title first">目录</p>
<ul class="simple">
<li><a class="reference internal" href="#lapi-c" id="id5">lapi.c</a></li>
<li><a class="reference internal" href="#lobject-h" id="id6">lobject.h</a></li>
<li><a class="reference internal" href="#lstate-h" id="id7">lstate.h</a></li>
</ul>
</div>
<hr class="docutils" />
<p>某天在 reddit 上面看到 LuaJIT 作者推荐的 Lua源码阅读顺序 ：</p>
<blockquote>
<ol class="arabic simple">
<li>lmathlib.c, lstrlib.c: get familiar with the external C API. Don't bother with the pattern matcher though. Just the easy functions.</li>
<li>lapi.c: Check how the API is implemented internally. Only skim this to get a feeling for the code. Cross-reference to lua.h and luaconf.h as needed.</li>
<li>lobject.h: tagged values and object representation. skim through this first. you'll want to keep a window with this file open all the time.</li>
<li>lstate.h: state objects. ditto.</li>
<li>lopcodes.h: bytecode instruction format and opcode definitions. easy.</li>
<li>lvm.c: scroll down to luaV_execute, the main interpreter loop. see how all of the instructions are implemented. skip the details for now. reread later.</li>
<li>ldo.c: calls, stacks, exceptions, coroutines. tough read.</li>
<li>lstring.c: string interning. cute, huh?</li>
<li>ltable.c: hash tables and arrays. tricky code.</li>
<li>ltm.c: metamethod handling, reread all of lvm.c now.</li>
<li>You may want to reread lapi.c now.</li>
<li>ldebug.c: surprise waiting for you. abstract interpretation is used to find object names for tracebacks. does bytecode verification, too.</li>
<li>lparser.c, lcode.c: recursive descent parser, targetting a register-based VM. start from chunk() and work your way through. read the expression parser and the code generator parts last.</li>
<li>lgc.c: incremental garbage collector. take your time.</li>
<li>Read all the other files as you see references to them. Don't let your stack get too deep though.</li>
</ol>
</blockquote>
<p>感觉很有道理，所以……就按他说的来吧~</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>唔，插一句…… GNU Global 真是神器！</p>
<p class="last">再插一句，其实他漏掉了第零步：Lua 文档</p>
</div>
<div class="section" id="lapi-c">
<h1><a class="toc-backref" href="#id5">lapi.c</a></h1>
<p>在 <cite>lapi.c</cite> 中，最重要的函数可以说是 <tt class="docutils literal">index2addr</tt> 了吧：</p>
<p id="index2addr"><strong>index2addr</strong> :</p>
<pre class="code c literal-block">
<span class="k">static</span> <span class="n">TValue</span> <span class="o">*</span><span class="nf">index2addr</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CallInfo</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">ci</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TValue</span> <span class="o">*</span><span class="n">o</span> <span class="o">=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
    <span class="n">api_check</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">-</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&quot;unacceptable index&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="k">return</span> <span class="n">NONVALIDVALUE</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">LUA_REGISTRYINDEX</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">api_check</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">-</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">-</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&quot;invalid index&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">LUA_REGISTRYINDEX</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">l_registry</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* upvalues */</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">LUA_REGISTRYINDEX</span> <span class="o">-</span> <span class="n">idx</span><span class="p">;</span>
    <span class="n">api_check</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">MAXUPVAL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;upvalue index too large&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ttislcf</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">))</span>  <span class="cm">/* light C function? */</span>
      <span class="k">return</span> <span class="n">NONVALIDVALUE</span><span class="p">;</span>  <span class="cm">/* it has no upvalues */</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">CClosure</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">clCvalue</span><span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">func</span><span class="o">-&gt;</span><span class="n">nupvalues</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">upvalue</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">NONVALIDVALUE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
<p>几乎所有其他的函数都是建立在它的功能之上的 —— 回忆 Lua 文档，
很多的 Lua API 函数都会接受一个 index 参数，用来指定参数在栈上的位置，比如 <tt class="docutils literal">lua_settop</tt>, <tt class="docutils literal">lua_remove</tt>, <tt class="docutils literal">lua_insert</tt>,
<tt class="docutils literal">lua_replace</tt> 等等，而这个 <a class="reference internal" href="#index2addr">index2addr</a> 函数的作用就是通过给定的 index 参数取出对应的 <a class="reference internal" href="#tvalue">TValue</a> 类型的对象指针</p>
<p>关于 Registry 的应用可以回忆 <a class="reference external" href="http://www.lua.org/manual/5.2/manual.html#4.5">Lua 文档上对于 Registry 的介绍</a> 。</p>
<p>而结合 <a class="reference internal" href="#pseudo-index">Pseudo Index</a> 可以看出该函数的逻辑如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<tbody valign="top">
<tr><td>当 index &gt; 0 时</td>
<td>在当前 function 的栈空间找对应的 TValue</td>
</tr>
<tr><td>当 LUA_REGISTRYINDEX &lt; index &lt;= 0 时</td>
<td>在当前 function 的栈空间逆向找对应的 TValue</td>
</tr>
<tr><td>当 index == LUA_REGISTRYINDEX 时</td>
<td>返回 registry</td>
</tr>
<tr><td>否则( index &lt; LUA_REGISTRYINDEX 时 )</td>
<td>查找 upvalue</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lobject-h">
<h1><a class="toc-backref" href="#id6">lobject.h</a></h1>
<p id="tvalue"><strong>TValue</strong> :</p>
<pre class="code c literal-block">
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">lua_TValue</span> <span class="n">TValue</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">lua_TValue</span> <span class="p">{</span>
  <span class="n">TValuefields</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TValuefields        Value value_; int tt_
</span>
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">#define LUA_NANTRICK 之后， TValuefields 会有不同的定义，不过基本原理不便，此处暂且假定
<strong>没有使用 LUA_NANTRICK</strong></p>
</div>
<p><cite>value_</cite> 项用于保存数据， <cite>tt_</cite> 项用于保存数据类型；
可选的数据类型有：</p>
<pre class="code c literal-block" id="id3">
<span class="cp">#define LUA_TNONE          (-1)
</span>
<span class="cp">#define LUA_TNIL           0
#define LUA_TBOOLEAN       1
#define LUA_TLIGHTUSERDATA 2
#define LUA_TNUMBER        3
#define LUA_TSTRING        4
#define LUA_TTABLE         5
#define LUA_TFUNCTION      6
#define LUA_TUSERDATA      7
#define LUA_TTHREAD        8
</span>
</pre>
<p>BTW 其中 function 类型又有三种区分：</p>
<ul class="simple">
<li>lua function</li>
<li>light C function</li>
<li>C function</li>
</ul>
<p>其中 light C function 与 C function 的区别在于前者只是一个 C 函数指针，
而后者可以有自己的 upvalue，即可以构成一个 closure。</p>
<p>string 类型有两种区分：</p>
<ul class="simple">
<li>short string</li>
<li>long string</li>
</ul>
<p>这两者的区别则在于前者会计算 hash 值，保证相同的短字符串全局唯一；
而为了避免 <a class="reference external" href="http://lua-users.org/wiki/HashDos">hash dos</a> ，长字符串并不计算 hash 值</p>
<pre class="code c literal-block">
<span class="cm">/* Variant tags for functions */</span>
<span class="cp">#define LUA_TLCL    (LUA_TFUNCTION | (0 &lt;&lt; 4))  </span><span class="cm">/* Lua closure */</span><span class="cp">
#define LUA_TLCF    (LUA_TFUNCTION | (1 &lt;&lt; 4))  </span><span class="cm">/* light C function */</span><span class="cp">
#define LUA_TCCL    (LUA_TFUNCTION | (2 &lt;&lt; 4))  </span><span class="cm">/* C closure */</span><span class="cp">
</span>
<span class="cm">/*
** LUA_TSTRING variants */</span>
<span class="cp">#define LUA_TSHRSTR (LUA_TSTRING | (0 &lt;&lt; 4))  </span><span class="cm">/* short strings */</span><span class="cp">
#define LUA_TLNGSTR (LUA_TSTRING | (1 &lt;&lt; 4))  </span><span class="cm">/* long strings */</span><span class="cp">
</span>
</pre>
<p id="value"><strong>Value</strong> :</p>
<pre class="code c literal-block">
<span class="k">union</span> <span class="n">Value</span> <span class="p">{</span>
  <span class="n">GCObject</span> <span class="o">*</span><span class="n">gc</span><span class="p">;</span>    <span class="cm">/* collectable objects */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>         <span class="cm">/* light userdata */</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>           <span class="cm">/* booleans */</span>
  <span class="n">lua_CFunction</span> <span class="n">f</span><span class="p">;</span> <span class="cm">/* light C functions */</span>
  <span class="n">numfield</span>         <span class="cm">/* numbers */</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">GCObject</span> <span class="n">GCObject</span><span class="p">;</span>
</pre>
<p>可以看出除了按值引用的数据（ light userdata, boolean, light C function, number ），
其他（ string, table, function, userdata, thread ）都是以 <a class="reference internal" href="#gcobject">GCObject</a> 指针形式保存，
以便用于垃圾回收</p>
<p id="pseudo-index"><strong>Pseudo Index</strong> :</p>
<pre class="code c literal-block">
<span class="cp">#define LUAI_FIRSTPSEUDOIDX (-LUAI_MAXSTACK - 1000)
</span>
<span class="cp">#define LUA_REGISTRYINDEX   LUAI_FIRSTPSEUDOIDX
#define lua_upvalueindex(i) (LUA_REGISTRYINDEX - (i))
</span>
</pre>
<p><strong>CommonHeader</strong> :</p>
<pre class="code c literal-block">
<span class="cm">/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/</span>
<span class="cp">#define CommonHeader        GCObject *next; lu_byte tt; lu_byte marked
</span>
</pre>
<p>CommonHeader 是 Lua 用于垃圾回收的结构，其中 <a class="reference internal" href="#gcobject">GCObject</a> * next 指向下一个可回收对象，
构成了一个单向链表，tt <a class="reference internal" href="#tvalue">依旧是</a> 用于保存数据类型，而 marked 则是用于标记垃圾回收的状态</p>
</div>
<div class="section" id="lstate-h">
<h1><a class="toc-backref" href="#id7">lstate.h</a></h1>
<p id="gcobject"><strong>GCObject</strong> :</p>
<pre class="code c literal-block">
<span class="k">union</span> <span class="n">GCObject</span> <span class="p">{</span>
  <span class="n">GCheader</span> <span class="n">gch</span><span class="p">;</span>  <span class="cm">/* common header */</span>
  <span class="k">union</span> <span class="n">TString</span> <span class="n">ts</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">Udata</span> <span class="n">u</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">Closure</span> <span class="n">cl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Table</span> <span class="n">h</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Proto</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">UpVal</span> <span class="n">uv</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">lua_State</span> <span class="n">th</span><span class="p">;</span>  <span class="cm">/* thread */</span>
<span class="p">};</span>
</pre>
</div>
<footer>Copyright &copy; <a href="http://www.if-yu.info/">If</a>.</footer>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="lua-notes.rst">View document source</a>.

</div>
</body>
</html>
